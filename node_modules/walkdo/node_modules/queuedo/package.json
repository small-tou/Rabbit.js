{
  "name": "queuedo",
  "description": "异步队列同步化，支持递归嵌套",
  "version": "0.9.6",
  "keywords": "queue asynchronous synchro",
  "contributors": [
    {
      "name": "yutou",
      "email": "xinyu198736@gmail.com"
    }
  ],
  "main": "./lib/queue_do.js",
  "licenses": [
    {
      "type": "GPLv2",
      "url": "http://www.example.com/licenses/gpl.html"
    }
  ],
  "repositories": "https://github.com/xinyu198736/queue_do",
  "dependencies": {},
  "readme": "queue_do\n========\n\n异步队列同步化，支持递归嵌套\n\n基于nodejs模块封装，同样适用于前端的异步同步化。\n\n#安装\n\n<pre>\nnpm install queuedo\n</pre>\n\nweb版见：lib/queue_do_webjs.js\n\n\n#原理和使用\n\n文章见：http://www.html-js.com/?p=1474\n\n支持异步同步化\n同步化后成队列后执行回调方法\n也可以异步处理队列，同时处理完毕后调用回调方法\n具体见代码中的注释\n\n * @param array list 需要处理的数据的数组，作为参数传入handle_func第一个参数。\n * @param function handle_func 处理方法，第一个参数为数组的一个元素，第二个参数传入的是下一个loop方法，第三个参数是其loop的context\n * @param function next_func 队列处理完毕后调用的方法。\n * @param boolen isAsyn 是否异步，如果是true，则不会同步化，可以利用next_func获取处理完毕的信号\n\n#一个例子，递归遍历某个文件夹下所有的图片并压缩到1000宽度。\n\n<pre>\nvar fs   = require('fs');\nvar path = require('path');\n//源文件\nvar source = '/Applications/XAMPP/xamppfiles/htdocs/htmljs';\n//目标文件\nvar target = '/Applications/XAMPP/xamppfiles/htdocs/htmljs_temp';\n//引入gm做图片处理器\nvar gm = require('gm');\nvar imageMagick = gm.subClass({\n    imageMagick: true\n});\nvar queue_do=require(\"./queue_do.js\")\nvar walk=function(_path,callback,next_func){\n    var list=[]\n    if(fs.existsSync(_path)){\n        var stat=fs.statSync(_path)\n        if(stat.isDirectory()){\n            fs.readdir(_path,function(error,files){\n                queue_do(files,function(__path,next,context){\n                    walk(_path+\"/\"+__path,callback,function(){\n                        next.call(context)\n                    })\n                },function(){\n                    next_func()\n                })\n            })\n        }else{\n            callback(_path)\n            next_func()\n        }\n    }\n}\nwalk(source,function(list){\n    console.log(list)\n},function(){\n    console.log(\"all finish!\")\n})\n\n</pre>\n\n几个异步方法的同步化：\n下面的例子是同步去请求豆瓣三个api，最后请求完后显示出来的例子。\n只是示例，完整程序的一部分，不能运行。\n<pre>\nvar queuedo=require(\"queuedo\");\nvar Douban = require(\"douban\");\nmodule.exports = function(req, res) {\n    var config = {\n        app_key:\"0bb4b9fc67f9b013231e2df537ed1039\",\n        app_secret:\"e7434521cb0c70ad\",\n        redirect_uri:\"http://localhost:8080/sina_auth_cb\",\n        access_token:req.cookies.token\n    }\n    var api = new Douban(config);\n    var datas=[\n        \n    ]\n    var functions=[\n    function(callback){\n        api.shuo.statuses({\n            source:config.app_key,\n            text:\"hello nodejs\"+Math.random()\n        },function(error,data){\n            datas.push({\n                api:\"shuo.statuses\",\n                data:data\n            });\n            callback();\n        });\n    }, function(callback){\n        api.shuo.home_timeline({},function(error,data){\n            datas.push({\n                api:\"shuo.home_timeline\",\n                data:data\n            })\n            callback();\n        });\n    }, function(callback){\n        api.shuo.user_timeline({\n            screen_name:\"mier963\"\n        },function(error,data){\n            datas.push({\n                api:\"shuo.user_timeline\",\n                data:data\n            })\n            callback();\n        });\n    }];\n    queuedo(functions,function(func,next,context){\n        func(function(){\n            next.call(context);\n        });\n    },function(){\n        res.render(\"shuo.html\",{\n            data:datas\n        })\n    });\n}\n</pre>",
  "_id": "queuedo@0.9.6",
  "dist": {
    "shasum": "9ed5249f5dd97e5da9943d1d8bd05fdd0214fdef"
  },
  "_from": "queuedo@0.9.6"
}
